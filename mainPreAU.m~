function mainPreAU  (inFile, outFile, displayFlag, learnFlag, learntDataFile)
% This is the main function that (i) sets up the parameters, (ii)
% initializes the spatial pooler, and (iii) iterates through the data and
% feed it through the spatial pooler and temporal memory modules.
%
% We follow the implementation that is sketched out at
%http://numenta.com/assets/pdf/biological-and-machine-intelligence/0.4/BaMI-Temporal-Memory.pdf
%
% Not all aspects of NUPIC descrived in the link below are implemented.
% http://chetansurpur.com/slides/2014/5/4/cla-in-nupic.html#42
%
% Parameters follow the ones specified at
%https://github.com/numenta/nupic/blob/master/src/nupic/frameworks/opf/common_models/anomaly_params_random_encoder/best_single_metric_anomaly_params_tm_cpp.json
%
%% Copyright (c) 2016,  Sudeep Sarkar, University of South Florida, Tampa, USA
% This work is licensed under the Attribution-NonCommercial-ShareAlike 4.0 International License. 
% To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
%
% on https://github.com/SudeepSarkar/matlabHTM

global  SP SM TP AU data anomalyScores predictions


if learnFlag
  %% Encode Input into Binary Semantic Representation 

   SP.width = 21; %21; % number of bits that are one for each state in the input.
   data = encoderNAB (inFile, SP.width);
  
    
   %% initialize parameters and data structures for spatial pooler (SP), 
   % sequence memory (SM), and temporal pooler (TP). 
   initialize;
    
    %% Learning mode for Spatial Pooler
    % We train the spatial pooler in a separate step from sequence memory
    fprintf(1, '\n Learning sparse distributed representations using spatial pooling...');
    trN = min (750, round(0.15*data.N)); 
    % use the first 15 percent of the data (upto a maximum of 750) samples for training the spatial pooler. 
    
    xSMPrevious = [];
    % AU.inputHistory => cells of arrays, each cell holds a array of a specific key, 
    % AU.inputHistory => each row in the array contains a different value for that specific key.
    AU.inputHistory = {0}; 
    AU.Counts = {0}; % Holds the count for all entries in AU.inputHistory. {similar structure as AU.inputHistory}
    AU.uniquePatterns = []; % Holds <key, value> pairs with highest counts
    AU.uniqueCounts = []; % Holds count of AU.uniquePatterns. 
    iteration = 1;
    
    while iteration < trN
        % [ToDo: Move this to a function called 'SPOutput']
        x = []; % construct the binary vector x for each measurement from the data fields
        for  i=1:length(data.fields)
            j = data.fields(i);
            x = [x data.code{j}(data.value{j}(iteration),:)];
        end
        
        % train the spatialPooler
        xSM = spatialPooler (x, true, false);

        % train the Automatization Unit (AU)
        if iteration > 2
            % check if the key is in the AU
            [~,AU.colLocation] = ismember(xSMPrevious,AU.uniquePatterns(:,1:size(xSMPrevious,2)),'row');
            if any(AU.colLocation)
                % check if the corresponding value exist
                [~,AU.rowLocation] = ismember(xSM,AU.inputHistory{1,AU.colLocation}(:,(size(xSM,2)+1):size(AU.uniquePatterns,2)),'row');
                if any(AU.rowLocation)
                    % Increase count of existing <key, value> pair
                    AU.Counts{1,AU.colLocation}(AU.rowLocation) = AU.Counts{1,AU.colLocation}(AU.rowLocation) + 1;
                else
                    % Add value and initialize count (1) to existing key
                    AU.inputHistory{1,AU.colLocation} = [AU.inputHistory{1,AU.colLocation}; xSMPrevious xSM];
                    AU.Counts{1,AU.colLocation} = [AU.Counts{1,AU.colLocation}; 1];
                end
            else
               % Add new key and value to inputHistory and uniquePatterns
               AU.inputHistory{1,size(AU.inputHistory,2)+1} = [xSMPrevious xSM];
               AU.uniquePatterns = [AU.uniquePatterns; xSMPrevious xSM];
               % Initialize counts
               AU.Counts{1,size(AU.Counts,2)+1} = 1;
               AU.uniqueCounts = [AU.uniqueCounts; 1];
            end
        elseif iteration == 2
            % Initialize inputHistory, uniquePatterns and counts
            AU.inputHistory{1} = [xSMPrevious xSM];
            AU.uniquePatterns = [xSMPrevious xSM];
            AU.Counts{1} = 1;
            AU.uniqueCounts = 1;
        else
            % Do nothing
        end
            
        
        %Can we reconstruct the input by inverting the process? This is
        %just for sanity check. It is NOT used for training the spatial
        %pooler
        ri = (xSM* double(SP.synapse > SP.connectPerm)) > 1;
        rError = nnz(x(1:data.nBits(1))) - nnz(ri(1:data.nBits(1)) & x(1:data.nBits(1)));
        if (rError ~= 0)
            fprintf(1, '\n (Non zero reconstruction error: %d bits) - ignore.', rError);
        end
        
        xSMPrevious = xSM;
        iteration = iteration + 1;
    end
    fprintf(1, '\n Learning sparse distributed representations using spatial pooling...done.');

%% already learnt spatial pooler and sequence memory is present in learntDataFile
else
    load (learntDataFile);
end
  
% Initialize plot areas
close all; 
if displayFlag
   % h1 = figure; set(h1, 'Position', [10, 10000, 700, 1000]);
   % h2 = figure; set(h2, 'Position', [1000, 10000, 700, 1000]);
    
   h = figure; set(h, 'Position', [10, 10000, 1400, 1000]);
   subplot(3,2,1);
   
    
end


%% Setup arrays
predictions = zeros(3, data.N); % initialize array allocaton -- faster on matlab
SM.inputPrevious = zeros(1,SM.N);
data.inputCodes = [];
data.inputSDR = [];
SP.boost = ones (SM.N, 1); 
% no boosting in spatial pooler as it is being run in a non-learning mode
% next


fprintf('\n Running input of length %d through sequence memory to detect anomaly...', data.N);

%% Iterate through the input data and feed through the spatial pooler, sequence memory and temporal pooler, as needed.

time = datetime;   % Used to calculate the execution time.
iteration = 1;
SM.input = [];
SM.inputNext = [];
anomalyScores = ones(1,data.N);
automatization = 0; % Counts the times AU is accessed.
AU.access_previous = 0;

while iteration < (data.N + 1)
    %% Run through Spatial Pooler (SP)(without learning)    
    if ~any(SM.input)
        % [ToDo: Will be processed through 'SPOutput']
        x = [];
        for  i=1:length(data.fields)
            j = data.fields(i);
            x = [x data.code{j}(data.value{j}(iteration),:)];
        end
        
        SM.input = spatialPooler (x, false, displayFlag);

        data.inputCodes = [data.inputCodes; x]; 
        data.inputSDR = [data.inputSDR; SM.input];

        % stores sequence of input to spatial pooler. This is used to
        % visualize the predicted vectors 
    end

    % Check for the key
    [~,AU.colLocation] = ismember(SM.input,AU.uniquePatterns(:,1:(size(SM.input,2))),'row');
    if any(AU.colLocation) && (iteration<data.N) && (iteration>trN)
        %AU.anomalyScore = 0;
        %% Get the next input to validate AU prediction.
        % [ToDo: Will be processed through 'SPOutput']
        x = [];
        for  i=1:length(data.fields)
            j = data.fields(i);
            x = [x data.code{j}(data.value{j}(iteration+1),:)];
        end
        SM.inputNext = spatialPooler (x, false, displayFlag);
        data.inputCodes = [data.inputCodes; x]; 
        data.inputSDR = [data.inputSDR; SM.inputNext];

        %AU.anomalyScore = 1 - nnz(AU.uniquePatterns(AU.colLocation,(size(SM.input,2)+1):size(AU.uniquePatterns,2)) & SM.input)/nnz(SM.input);
        
        % check if value exist in inputHistory
        [~,AU.rowLocation] = ismember(SM.inputNext,AU.inputHistory{1,AU.colLocation}(:,(size(SM.inputNext,2)+1):size(AU.uniquePatterns,2)),'row');
        %fprintf("\n AU.rowLocation = %d\n",AU.rowLocation);
        
        % Compare AU prediction with next input
        AU.access = (AU.uniquePatterns(AU.colLocation,(size(SM.input,2)+1):size(AU.uniquePatterns,2)) == SM.inputNext);
        if AU.access
            if anomalyScores (iteration) == 0
                % Prevents overriding the score calculated in the AU
            else
                predictedInput = logical(sum(SM.cellPredicted));
                anomalyScores (iteration) = 1 - nnz(predictedInput & SM.input)/nnz(SM.input);
            end
%           [Done: Strengthen permanences between SM.inputPrevious (synapses) and SM.input (neurons)]
%           [Done: AU.access_previous == 1 % will check if the previous iteration was through AU or HTM for proper HTM learning]
            if AU.access_previous == 1
                % Sequence memory already learned in previous iteration
            else
                markActiveStates (); % based on x and PI_1 (prediction from past cycle)
                if learnFlag
                   markLearnStates ();
                   updateSynapses ();
                end
            end
            anomalyScores (iteration+1) = 0;
            % Increase count of <key, value> pair
            AU.Counts{1,AU.colLocation}(AU.rowLocation) = AU.Counts{1,AU.colLocation}(AU.rowLocation) + 1;
            % Update uniqueCounts for that key
            AU.uniqueCounts(AU.colLocation) = AU.uniqueCounts(AU.colLocation) + 1;
            SM.inputPrevious = SM.input;
            SM.input = SM.inputNext;
            SM.inputNext = [];
%           [Done: Strengthen permanences between SM.input (synapses) and SM.inputNext (neurons)]
            SM.cellActivePrevious = SM.cellActive;
            SM.cellLearn(:) = 0;
            SM.cellLearn(:,SM.input) = 1;
            [dendrites, ~, cellID] = find(SM.dendriteToCell); % note: same cellID might be repeated
            reinforceDendrites = (SM.cellLearn(cellID) == 1);
            [~, ~, dendriteID] = find(SM.synapseToDendrite);
            [synapse, ~, ~] = find(SM.synapseToCell);
%%            [ToDo: Update Sm.cellActive and SM.cellLearn]
            
            SM.cellActive = SM.cellLearn;
            reinforceSynapses = ismember(dendriteID, dendrites(reinforceDendrites));
            strengthenSynapses = synapse(reinforceSynapses & (SM.synapsePermanence(synapse) < 1));
            SM.synapsePermanence(strengthenSynapses) = SM.synapsePermanence(strengthenSynapses) + SM.P_incr;
            SM.cellPredictedPrevious = SM.cellPredicted;  
            SM.cellActivePrevious = SM.synapseToCell(strengthenSynapses);
            SM.cellLearnPrevious = SM.synapseToCell(strengthenSynapses);
            AU.access = 0;
            AU.access_previous = 1; % flag to ensure propper HTM-AU Sync
            automatization = automatization + 1; % Increment AU access
            iteration = iteration + 1;
        else
            %% Compute anomaly score 
            % based on what was predicted as the next expected sequence memory
            % module input at last time instant.
            if AU.access_previous == 1
                % Prevents overriding the score calculated in the AU
                %% %%%%%%%% [ToDo: Compute prediction with SM.inputNext (synapses) as an input]
                % Predict next state
                markPredictiveStates ();
            else
                predictedInput = logical(sum(SM.cellPredicted));
                anomalyScores (iteration) = 1 - nnz(predictedInput & SM.input)/nnz(SM.input);
                %% Run the input through Sequence Memory (SM) module to compute the active
                % cells in SM and also the predictions for the next time instant.
                sequenceMemory (learnFlag);

                if any(AU.rowLocation)
                    % Increase count of <key, value> pair
                    AU.Counts{1,AU.colLocation}(AU.rowLocation) = AU.Counts{1,AU.colLocation}(AU.rowLocation) + 1;
                    % Check the key column for the value with maximum count
                    [AU.maxCount,AU.rowLocation] = max(AU.Counts{1,AU.colLocation});
                    % Update uniqueCounts for that key
                    AU.uniqueCounts(AU.colLocation) = AU.maxCount;
                    % [ToDo: Check if the max <key, value> pair has changed before updating it]
                    % Update uniquePatterns with max count
                    AU.uniquePatterns(AU.colLocation,:) = [SM.input SM.inputNext];
                else
                    % Adds <key, value> pair to existing key column and initializes count.
                    AU.inputHistory{1,AU.colLocation} = [AU.inputHistory{1,AU.colLocation}; SM.input SM.inputNext];
                    AU.Counts{1,AU.colLocation} = [AU.Counts{1,AU.colLocation}; 1];
                end
            end

            SM.inputPrevious = SM.input;
            SM.input = SM.inputNext;
            SM.cellActivePrevious = SM.cellActive;
            SM.cellLearnPrevious = SM.cellLearn;
            AU.access_previous = 0; % flag to ensure propper HTM-AU Sync
            iteration = iteration + 1;
        end
    else
        if AU.access_previous == 1
            % Prevents overriding the score calculated in the AU
            %% %%%%%%%% [ToDo: Compute prediction with SM.inputNext (synapses) as an input]
            % Predict next state
            markPredictiveStates ();
        else
            %% Compute anomaly score 
            % based on what was predicted as the next expected sequence memory
            % module input at last time instant.
            if anomalyScores (iteration) == 0
                % Prevents overriding the score calculated in the AU
            else
                predictedInput = logical(sum(SM.cellPredicted));
                anomalyScores (iteration) = 1 - nnz(predictedInput & SM.input)/nnz(SM.input);
            end

            %% Run the input through Sequence Memory (SM) module to compute the active
            % cells in SM and also the predictions for the next time instant.
            sequenceMemory (learnFlag);

            % Skips training data
            if iteration > trN
                % Create a new cell in AU.inputHistory and initialize the Counts
                AU.inputHistory{1,size(AU.inputHistory,2)+1} = [SM.inputPrevious SM.input];
                AU.Counts{1,size(AU.Counts,2)+1} = 1;
                % Create a new entry in AU.uniquePatterns and initialize uniqueCounts
                AU.uniquePatterns = [AU.uniquePatterns; SM.inputPrevious SM.input];
                AU.uniqueCounts = [AU.uniqueCounts; 1];
            end
        end

        SM.inputPrevious = SM.input;
        SM.cellActivePrevious = SM.cellActive;
        SM.cellLearnPrevious = SM.cellLearn;
        AU.access_previous = 0; % flag to ensure propper HTM-AU Sync
        SM.input = [];
        iteration = iteration + 1;
    end

    %% Temporal Pooling (TP) -- remove comments below to invoke temporal pooling.
    %     if (iteration > 150)
    %        perform only after some iterations -- pooling makes sense over
    %        a period of time.
    %         temporalPooler (true, displayFlag);
    %         TP.unionSDRhistory (mod(iteration-1, size(TP.unionSDRhistory, 1))+1, :) =  TP.unionSDR;
    %
    %     end;
    %% This part of the code is just for display of variables and plots/figures
    
    
    if (displayFlag)
        
        if (iteration > 2)
            %figure(h2);
            subplot(3,2,[2,4,6]);
            
            displayCellAnimation;
            %figure(h1);
            visualizeHTM (iteration);
        end
        subplot(3,2,[2,4,6]); hold on;
        text(-0.5, -0.08, sprintf('SM.totalDendrites: %d, SM.totalSynapses: %d', ...
            SM.totalDendrites, SM.totalSynapses), 'fontsize', 16);
        hold off;
        pause (0.00001);
    else
        if (rem (iteration, 100) == 0) % display every 100 iterations
        fprintf(1, '\n Fraction done: %3.2f, SM.totalDendrites: %d, SM.totalSynapses: %d', ...
            iteration/data.N, SM.totalDendrites, SM.totalSynapses);
        end
    end
    
    
    %%
%    SM.inputPrevious = SM.input;
    SM.cellActivePrevious = SM.cellActive;
    SM.cellLearnPrevious = SM.cellLearn;
    
end
fprintf ('\nProcessing Time is: %s\n',diff([time datetime]));
fprintf ("\nAutomatization Access: %d",automatization);
fprintf('\n Running input of length %d through sequence memory to detect anomaly...done', data.N);

% Uncomment this if you want to visualize Temporal Pooler output
% imagesc(TP.unionSDRhistory); pause (0.00001);
% pause (0.0000000000001);

%% Save data
if learnFlag
    save (sprintf('Output/HTM_SM_%s.mat', outFile), ...
        'SM', 'SP', 'data', 'anomalyScores', 'predictions',...
        '-v7.3');
else
    save (sprintf('Output/HTM_SM_%s_L.mat', outFile), ...
        'SM', 'SP', 'data', 'anomalyScores', 'predictions',...
        '-v7.3');
end





